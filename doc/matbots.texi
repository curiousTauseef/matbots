\input texinfo    @c -*-texinfo-*-
@c %**start of header
@setfilename matbots.info
@settitle Matbots Manual
@c %**end of header

@copying

Copyright @copyright{} 2007 Michael Abraham and Christopher Wellons

@quotation 
Copying, modification, and distribution of this document is permitted
worldwide, without royalty, in any medium, provided this notice is
preserved.
@end quotation
@end copying

@titlepage
@title Matbots Manual
@subtitle Official Manual and Bot Programming Guide
@author Michael Abraham and Christopher Wellons

@page
@vskip 0pt plus 1filll
@insertcopying

@end titlepage

@contents

@ifnottex
@node Top
@top Matbots

@insertcopying
@end ifnottex

@menu
* Preface::              An introduction
* Setup::                Setting up a game
* Programming Basics::   Basic bot information
* Creating a Bot::       Writing a bot by example
* Bot Behavior::         Bot features and etiquette
* Simple Example::       A simple example bot
* Targeting Bot::        Simple example extended for targeting
* Index::                Concept index
@end menu

@c Preface
@node Preface
@unnumbered Preface

@c boring as hell!!! fix this
@c XXX write more and make it more interesting

This game we have going here began as a small project by Michael
Abraham. To kill some time, he wrote a program where one circle chased
another circle around a plot. Chris Wellons suggested that the engine
be extended to allow different bots to be written and plugged in.

Eventually, these bots could do things like fire bullets and drop
mines. People nearby began to notice the bots at war on our computer
screens and became interested in writing bots.

By having these bots written in Matlab, you have all of Matlab's tools
at your disposal. You can also interface with external tools as well,
which means you could write your bot in C or C++ and make calls to
your external program from Matlab.

@c ---------------------------------------------------------------------
@c Setup
@node Setup
@chapter Setup

@menu
* Invocation::         Invoking the engine
* Engine Settings::    Game options and settings
@end menu

@c Invocation
@node Invocation
@section Invocation

@cindex player list
@cindex player_list.txt
To set up a game, edit the file called @file{player_list.txt}. This
file should contain a bot name and a bot team name on each line
separated by space. For example,

@example
sniper red_team
sniper red_team
sniper red_team
goose  blue_team
goose  blue_team
goose  blue_team
@end example

The above @file{player_list.txt} file would set up a game of three
sniper bots on team "red_team" against three goose bots on team
"blue_team".  Any combination of bots and teams is allowed.

@cindex engine_settings.m
@cindex settings
@cindex engine settings
The game options and settings are stored in
@file{engine_settings.m}. This file is executed by the engine to
obtain all in-game values. Bots may also use this to obtain the same
information for use in its programming. @xref{Engine Settings}.

@cindex engine.m
To start a game, simply execute the file @file{engine.m},

@example
>> engine
@end example

@c Engine Settings
@node Engine Settings
@section Engine Settings

@cindex engine_settings.m
The file @code{engine_settings.m} stores all of the game settings and
options that effect the gameplay, logging, and display. The following
explains these different settings found in the above file.

@menu
* World Settings::     Settings that define the game world
* Display Settings::   Settings that effect the graphics of the game
* Player Settings::    Settings that directly effect players
@end menu

@c World Settings
@node World Settings
@subsection World Settings
@cindex world settings

@cindex world
The size of the game map is given in a 1 by 4 vector called
@code{world},

@example
world = [minX maxX minY maxY];
@end example

All activity, weapons, and bots must happen within this
boundary. Nothing can exist outside these bounds.

The time step of the engine is defined in the @code{ts} variable. A
lower number will give more precision to the game but result in
greater processing time to simulate the game.

@cindex friendly fire
@code{friendly_fire} enables friendly fire for the game. With friendly
fire turned on, bullets and mines will hurt fellow teammates in the
game.

@cindex player mask
@cindex hiding player information
@cindex function handle
@code{player_hide} is a vector of integers that masks values in the
player state vector (@pxref{Data Structures}) Changing this can
severely break many bots. It is suggested to leave this as @code{[8
10]}, which will mask other player's headings and bot function
handles.

@cindex grouping teams
@code{group_teams} decides how players are initially placed in the
world. When enabled, players are grouped with their teams and the
teams are placed evenly around the outside of the world.

@code{group_teams_radius} determines the radius of the circle in which
an entire team starts when @code{group_teams} is enabled. If this is
set to 0, all teams members will be exactly on top of each other.

@c Display Settings
@node Display Settings
@subsection Display Settings
@cindex display settings

This section contains settings that effect the display of the world
during the game as well as the recordings from that game. Changing
these have no effect on the game, except maybe to cause it to take
longer to play out.

@code{heading_length} is the length of the line that shows a bot's
heading. By default, this is set to scale by the world size so that
the heading length will appear the same across different world sizes.

@code{display_game} determines whether or not the game is displayed
during the run. When disabled, the game will still run the same way
but there will be no visual output.

@cindex record
The next two settings, @code{record_game} and @code{script_game},
involve game recordings. These are two ways to record a game.

@cindex record game
When @code{record_game} is enabled, the game is captured using
Matlab's @code{getframe} command. This means that when this option is
set, @code{display_game} is also set, no matter what. This can be used
to convert a game video into a movie file for play outside of Matlab.

@cindex script game
With @code{script_game}, the game display is dumped to an m-file by
the name stored in @code{script_file}. This works by putting all
@code{plot} and @code{text} commands to an m-file along with all the
data needed (@pxref{Bot Plotting}). This m-file can be played back
from any instance of Matlab anywhere without the engine or any bots
present. This means you can share the recording with anyone who has
Matlab. Because it records plot commands, the ``video'' has infinite
resolution and can be played back at any size without loss of quality.

The scripted game also has built-in recording facilities, allowing it
to be easily converted into a video file. To turn this on, edit the
first line of the script to set @code{record_game} to 1 instead of
0. All video data will be dumped to a variable called @code{watch}.

In-game data can also be logged and this log data is placed into a
structure called @code{bots} and stored in the file named by
@code{log_file}. Logging is enabled with @code{log_game}.

The game also supports putting health and energy bars above
players. These are controlled by the remaining
settings. @code{display_health} and @code{display_energy} controls
whether these bars are visible or not. The other three settings,
@code{bar_length}, @code{bar_offset}, and @code{bar_stack_offset}
controls the look of the bars: length, distance from each other,
distance from player, respectively.

@c Player Settings
@node Player Settings
@subsection Player Settings
@cindex player settings

The player settings effect bots directly and are fairly simple
settings. These control health, energy, and movement.

@cindex energy
@cindex health
@code{energy_max} and @code{health_max} control the maximum energy
and health respectively. Generally, increasing health will make games
longer and increasing energy will make games shorter.

@code{energy_regen} and @code{health_regen} control the energy and
health regeneration rates. Setting these values to zero disables the
respective regeneration ability.

@cindex movement
@code{move_cost} is the energy cost of moving a bot. The actual
movement cost is a percentage of this value based on throttle. 50%
throttle will use half of this energy and 100% throttle will use the
entire @code{move_cost} amount.

@cindex deltaH
@code{deltaH_max} is the maximum amount of angular distance a bot can
turn at once. Setting this to a low value will greatly reduce the
movement capabilities of the bots. Setting this value high will make
the games look boring (really!).

@c ---------------------------------------------------------------------
@c Programming Basics
@node Programming Basics
@chapter Programming Basics

@menu
* Data Structures::    Bot data structures
* Bot Interface::      The interface between the engine and the bot
* Actions::            Bot actions
* Requests::           Engine requests
* Objects::            Objects found in the game
@end menu

@c Data Structures
@node Data Structures
@section Data Structures

@cindex state vector
A bot's current state is completely described by its state vector.
The state vector is stored as a 1 by 9 cell array. The values are
stored in this order,

@enumerate
@item
X-position (double precision)

@item
Y-position (double precision)

@item
Health (double precision)

@item
Energy (double precision)

@item
Team (string)

@item
Player number (integer)

@item
Bot Function (string)

@item
Heading (double precision)

@item
Color (integer vector)

@item
Bot function handle (function handle)

@end enumerate

@cindex player position
The @var{x-position} and @var{y-position} are straightforward: each is
a floating point value between the defined world boundaries, stored in
@code{world}. These are Cartesian coordinated with the origin is on
the bottom left and increasing values going right and up.

@cindex health
The @var{health} is a value between 0 and @code{health_max}. When a
bot's health is 0, this bot is dead and is removed from the game.

@cindex energy
The bot's @var{energy} is the fuel used to execute most, if not all,
actions: movement, shooting, dropping mines, self-destruct. Energy
slowly regenerates at the rate stored in @code{energy_regen}. If a
bot's energy is zero, the bot probably cannot do anything but wait for
energy to regenerate.

The @var{team} is a string that identifies which team a bot is playing
on. The team name is arbitrary and two bots are on the same team if
their team names match. Teams share a common color.

@cindex player number
The @var{player number} is a @emph{unique} number assigned to each bot
before the game begins. This number will never change during the
course of a game. This means that if a bot dies, the player numbers
are not adjusted. For example, there are four players at the beginning
of a game, which are assigned numbers 1 through 4. When player number
3 dies, the remaining players will be 1, 2, and 4. Player 4 is
@emph{not} changed into player 3. Confusion on this point is a cause
of many programming errors.

@cindex function name
The @var{bot function name} is the name of the function that defines
the bot. This is used by the engine to decide what function to call
when running the simulation. It can also be used for organizing teams
or targeting particularly dangerous enemies.

@cindex heading
The @var{heading} is a number between -pi and pi that describes the
direction a bot is facing. A heading of 0 means that a bot is facing
to the right, east, or the positive x direction.

@cindex color
The @var{color} is simply the color that the engine is using to plot
the bot. This is of very little use to bot programming.

@cindex function handle
The @var{bot function handle} is the function handle that the engine
uses to call the bot. This is not useful for bots and will generally
not be available to bots in the state vectors.

@c Bot Interface
@node Bot Interface
@section Bot Interface
@cindex interface

Bots are Matlab functions.  They accept four inputs and return three
outputs,

@example
function [deltaH throttle action] ...
                          = botname (state, player, objects, req)
@end example

@cindex state vector
@code{state} is a 1 by n cell array. The n cells are state vectors for
every @emph{other} living (or very recently living) bot in the
game. To access the information in a cell array, you will probably
want to use squiggly brackets.

For example, if you were interested in the health of the second bot in
the list, you would want

@example
state@{2@}@{3@}
@end example

Note the use of squiggly brackets rather than parenthesis. Also note
that this is not necessarily the health of player 2. Rather, this is
the health of the second bot in the array. This could very well be
player 13 if several bots have already died and have been removed from
the player list. To get the player number of the second bot in the
list, you would want to use

@example
state@{2@}@{6@}
@end example

The second argument @code{player} is the current bot's state vector
(the 1 by 9 cell array). This means that @code{player@{1@}} is the
current bot's x-position. @code{player@{2@}} is the current bot's
y-position, etc.

@cindex objects
@code{objects} is a cell array containing information about all the
various objects that are in the playing field that are visible to the
current bot. Each cell contains a state vector for an object. The
first cell in each object state vector is the name of the type of
object. For details on objects, @ref{Objects}.

@cindex requests
@code{req} is a @var{request}. The engine uses this input to make
requests to the bot. In normal gameplay, this will be an empty
string. If the string is not empty, the bot should either perform the
request action or do nothing at all. The most important @var{requests}
are @code{preclean} and @code{clean}. These are used to tell the bot
to clean up files and such before and after the game. @xref{Requests}.

@cindex well behaved
A well behaved bot should always return three values. There are a few
times when returning no values will not cause problems, but returning
values will do not harm.

@cindex heading
@cindex deltaH
@code{deltaH} is a @emph{change} in heading angle (in radians). This
value turns by the given angle. This angle may only be between
@code{-deltaH_max} and @code{deltaH_max}. Values exceeding these
values will be silently trimmed. For example, if the current heading
is pi/3 and the desired heading is pi/6, the deltaH would need to be
-pi/6.

@cindex throttle
@code{throttle} is a commanded speed. A positive throttle value
represents motion in the direction of the heading. @code{throttle}
should be a value between -1 and 1. A throttle value of 1 will move
the bot at a speed of 1 world unit per second. The energy per timestep
required for a throttle setting of 1 is @code{move_cost}.

@cindex action
@code{action} is a string containing the bot @var{action} for this
turn. @xref{Actions}.

@c Actions
@node Actions
@section Actions
@cindex actions

@menu
* Rifle::             Shooting a bullet
* Mine::              Dropping a mine
* Health to Energy::  Converting health to energy and vice-versa
* Self Destruct::     Self destruction to harm others
@end menu

To perform no action at all, simply return @code{'none'} for
@var{action}.

@c Rifle
@node Rifle
@subsection Rifle
@cindex rifle

@code{'rifle'} fires a bullet along the bot's next heading (current
heading + @code{deltaH}). The speed of the bullet is:
@code{rifle_speed}, radius of the bullet damage is
@code{rifle_radius}, damage caused by a hit is @code{rifle_damage},
and the energy required to fire a bullet is @code{rifle_cost}.

Currently, the engine models a rifle shot by a straight line of
tangent circles. This leaves significant gaps along the path that a
bot may find itself in. This behavior may change in the future and it
is encouraged to treat bullets as rectangular envelopes along the path
of the bullet.

Bullets disappear after leaving the bounds of the world. They will
also disappear after striking a target. If two targets are on top of
each other (or both within @code{rifle_radius}) both targets will be
damaged. This allows a single rifle shot to damage more than one bot
at a time.

@c Mine
@node Mine
@subsection Mine
@cindex mine

@code{'mine'} drops a mine at the bot's current location. The mine
explodes and disappears when a player comes within its detection
radius, @code{mine_radius}. The blast radius (the distance where bots
receive damage) is equal to the detection radius. The damage caused by
a mine is @code{mine_damage}. The energy required to drop a mine is
@code{mine_cost}.

A mine sits passively on the ground until another bot who can be
damaged by the mine comes too close. If no bot ever approaches the
mine, the mine will sit there forever (or until the game ends). If two
bots wander in range at the same time, they will both be hurt.

@c Health to Energy
@node Health to Energy
@subsection Health to Energy
@cindex health to energy transfer
@cindex energy to health transfer
@cindex transfer

@code{'HtoE'} will convert health to energy. The amount converted is
indicated by appending the amount to convert onto the action
string. For example, to convert 10 health to energy, the action string
would be @code{'HtoE10'}. The conversion rate between health and
energy is stored in @code{health_energy_ratio}. You might code it as,

@example
% Convert 10 health to energy
action = ['HtoE' num2str(10)];
@end example

Attempting to convert health into more energy than you can add is safe,
i.e. a bot will not lose health when energy is maxed out. A bot
@emph{can}, however, kill itself by transferring all health to energy.

This process also works in reverse to convert energy to health. Do
this by appending a negative number. For example, @code{'HtoE-8'} will
convert energy into 8 health.

@c Self Destruct
@node Self Destruct
@subsection Self Destruct
@cindex suicide
@cindex self destruct

@code{'destruct'} will cause the bot to instantly die leaving behind
an explosive with blast radius @code{destruct_radius}. This explosive
will go off after a length of time @code{destruct_time}. Remember to
take the time step into account. This means the explosive will go off
in @code{destruct_time/ts} steps.

Note that if the last remaining bot on a team does this, the team will
be eliminated before the explosive goes off. This could mean the end
of the game and the self destruct damage never happens.

@c Requests
@node Requests
@section Requests
@cindex requests

Currently there are only two requests that the engine makes. There
will be more in the future, which means that a bot should always
return values and be prepared for unknown requests. Basically this
means that ignoring unknown requests by returning empty or zero values
when they come up.

@menu
* Clean and Preclean::    Bot pre-game and post-game cleanup
* Selfdraw::              Bots that can draw themselves
@end menu

@c Clean and Preclean
@node Clean and Preclean
@subsection Clean and Preclean

@cindex preclean
Before every game, the engine will send a @code{'preclean'} requests
to every bot. The state vector (the first argument) will be empty,
which may cause simple bots to declare victory. The player vector is
provided as this may be important chosen filenames.

Use this to prepare any data files that are needed for the game. More
importantly, it allows the bot to clean up files that may be left over
from previous games that may interfere.

@cindex clean
At the end of every game, the engine will send a @code{'clean'}
request to each bot, again with an empty state vector but valid player
vector. A well behaved bot removes its game files.

@c Selfdraw
@node Selfdraw
@subsection Selfdraw
@cindex selfdraw

@cindex eplot
The @code{'selfdraw'} request is a query to the bot about drawing
preference. That is, if the bot responds with a yes, the bot indicates
that it would like to handle its own drawing routines with
@code{eplot} (@pxref{Bot Plotting}).

To reply with a yes, the @code{action} field must be equal to
@code{'selfdraw'}, the same as the request. The simplest way to
respond in the positive is,

@example
if strcmp(req, 'selfdraw')
    deltaH = 0;
    throttle = 0;
    action = req;
    return;
end
@end example

The bot's drawing should generally remain inside of a 0.25 by 0.25
area, or within radius of 0.125. For visibility purposes, the heading
line may extend beyond this limit, just as the @code{heading_length}
probably does. But do not let these boundaries interrupt creative
juices, of course!

@cindex radial
If the bot's drawing shape is not going to be radial (like the default
circle shape), it would be wise for the bot to rotate its drawing to
match its new heading. This can be done with a rotation
transformation,

@cindex rotation transformation
@cindex rotation
@example
rotation_matrix = [ cos(heading) -sin(heading)  ; ...
                    sin(heading)  cos(heading) ];
@end example

If the bot's drawing vectors are stored in @code{x} and @code{y},

@example
rotated_vectors = rotation_matrix * [ x ; y ];
@end example

And then we just plot this,

@example
eplot (rotated_vectors(1,:), rotated_vectors(2,:), ...
       'Color', player@{9@});
@end example

@cindex box
This example will draw a bot as a box with a heading line,

@example
engine_settings;

px = player@{1@};
py = player@{2@};

x = [-1  1  1 -1 -1] * .125;
y = [ 1  1 -1 -1  1] * .125;

% new heading
nh = player@{8@} + deltaH;

rot_mat = [cos(nh) -sin(nh); sin(nh) cos(nh)];
p = rot_mat * [x;y];

% Box
eplot(p(1,:) + px, p(2,:) + py, 'Color', player@{9@});

% Heading
eplot( ...
	[px, px + cos(nh) * heading_length], ...
	[py, py + sin(nh) * heading_length], ...
	'Color', player@{9@});
@end example

The box will rotate to face the same direction as the bot.

@c Objects
@node Objects
@section Objects
@cindex objects

Currently, all bots can see all objects in the game field, which
includes the bullets from @code{'rifle'} shots. This means a bot can
dodge bullets if it is clever enough.

@cindex state vector
All object state vectors (@pxref{Data Structures}) begin with the name
of the object.

@menu
* Rifle Object::     Bullets in the battlefield
* Mine Object::      Mines dropped by players
@end menu

@c Rifle Object
@node Rifle Object
@subsection Rifle Object
@cindex rifle

The rifle state vector looks like this,

@enumerate
@item
Object name (@code{'rifle'})

@item
X position

@item
Y position

@item
Heading

@item
Team

@item
Player

@item
Color

@end enumerate

The bullet is at (@var{x-position}, @var{y-position}) and moving in
direction @var{heading}. The shot was fired by @var{player} and
belongs to team @var{team}. When @code{friendly_fire} (@pxref{World
Settings}) is on, the team field is ignored by the engine. The
@var{color} value may be useful with @code{eplot} (@pxref{Bot
Plotting}).

@c Mine Object
@node Mine Object
@subsection Mine Object
@cindex mines

A mine is basically a bullet that does not move. Or, perhaps, a bullet
is a mine that moves. Here is the state vector,

@enumerate
@item
Object name (@code{'mine'})

@item
X position

@item
Y position

@item
Team

@item
Player

@item
Reserved

@item
Color

@end enumerate

The mine is located at (@var{x-position}, @var{y-position}), belongs
to team @var{team} and bot @var{player}. If @code{friendly_fire}
(@pxref{World Settings}) is on, the @var{team} field is ignored by the
engine. The @var{reserved} field was originally reserved as a list of
bots that can see the mine. This is not implemented and this field is
empty for now.

The @var{color} value may be useful with @code{eplot} (@pxref{Bot
Plotting}).

@c ---------------------------------------------------------------------
@c Creating a Bot
@node Creating a Bot
@chapter Creating a Bot

This chapter will go through a step-by-step process of creating a
simple seek and destroy bot that has memory. Even if you think you are
ready to get started, you should take a look at this chapter to see
how to avoid making come mistakes. It is also a guide on creating well
behaved bots.

@menu
* Initialization::        Getting things started in the bot
* Handling Requests::     How to handle requests from the engine
* Moving and Shooting::   Moving and shooting
* Memory::                Getting data from previous turns
* Targeting::             Choosing a target
@end menu

@c Initialization
@node Initialization
@section Initialization
@cindex initialization

@cindex boilerplate
First, you should drop in the function boilerplate (with your bot's
name) at the top of the file,

@example
function [deltaH throttle action] ...
                          = bot_name (state, player, objects, req)
@end example

Replace @code{bot_name} with the name of your bot (and the m-file).

@cindex engine_settings.m
Every non-trivial bot should call @code{engine_settings} at the
beginning of the bot's code. This will provide access to all of the
game settings. This will allow you to write a bot that doesn't contain
magic numbers or is tuned to any particular configuration.

Another good idea is to set all of the outputs in the case that they
are not set later before the function returns.

@example
deltaH = 0;
throttle = 0;
action = '';
@end example

@c Handling Requests
@node Handling Requests
@section Handling Requests
@cindex requests

Below is a boilerplate for handling requests,

@example
if isempty(req)
        % Continue as normal
elseif strcmp(req, 'preclean') 
        % Initialize files and external data
elseif strcmp(req, 'clean')
        % Clean up any created files and external mess
else
        % Ignore (unknown request)
        deltaH = 0;
        throttle = 0;
        action = '';
        return;
end
@end example

Putting this near the top of the bot program will allow the bot to
handle incoming requests before doing anything possibly
unnecessary. The above example handles @code{'clean'} and
@code{'preclean'} while ignoring unknown requests.

@xref{Requests}.

@c Moving and Shooting
@node Moving and Shooting
@section Moving and Shooting
@cindex movement
@cindex shooting

@cindex throttle
Moving involves setting @code{throttle} to anything but 0. It is
limited to values between -1 and 1, but values exceeding these are
silently trimmed. This may allow the bot logic to be more elegant and
simple.

@example
throttle = 0.5;
@end example

For shooting, we will use the @code{'rifle'}. By setting @code{action}
to @code{'rifle'}, the bot fire a single shot along the bot's
heading. If @code{action} always equals @code{'rifle'}, the bot will
constantly fire.

@example
action = 'rifle';
@end example

When deciding how to shoot, it is important to note the order in which
the engine will execute the bot actions,

@cindex execution order
@cindex order of execution
@enumerate
@item
Changes heading by @code{deltaH}

@item
Executes the action (@code{rifle}, @code{mine}, etc.)

@item
Moves the bot a distance of @code{throttle * ts} along the new heading.

@item
Moves and evaluates objects, causing damages where necessary.

@end enumerate

If the return values are @code{[ -pi/8, 1, 'rifle' ]}, the bot will
change heading @emph{first}, fire a rifle @emph{second} from the
current location along the new heading, and move to a new location
@emph{third}.

So with the code below, we have a bot that goes in a circle and fires
constantly (really it fires until it is out of energy). Copy any paste
this into a new bot function to try it for yourself.

@example
throttle = 0.5;
deltaH = pi / 8;
action = 'rifle';
@end example

@cindex well behaved
This simple bot is a @emph{well behaved} bot that will correctly handle all
requests.

@c Memory
@node Memory
@section Memory
@cindex memory

Memory involves saving variables that a bot may need later into a
@file{.mat} file. This mat file should be unique for the bot, or at
least the bot's team. If it isn't, the bot may interfere with enemy
bots attempting to use the same file.

Here is an example of memory being used to reduce the fire rate of the
bot in the previous section,

@example
datafile = ['example-bot-' num2str(player@{6@}) '.mat'];

if exist (datafile, 'file')
    load (datafile);
else
    rifle_timer = 0;
end

% This code is from before
deltaH = pi / 8;
throttle = 0.5;

% Do we shoot now?
if rifle_timer > 20
    % reset timer
    rifle_timer = 0;

    action = 'rifle';
else
    action = '';

    % increase timer
    rifle_timer = rifle_timer + 1;
end

save (datafile, 'rifle_timer');
@end example

@cindex unique filename
The name for the bot will be unique, based on the player number. This
will allow many of these bots in a single game without any of them
using the same file. Before the bot finishes, it saves the data to the
@file{.mat} file for the next turn.

@cindex well behaved
@cindex magic number
There are two issues with this bot that prevents it from being a
@emph{well behaved} and well written bot,

@itemize
@item
It does not clean up after itself.

@item
It uses a magic number, 20.

@end itemize

The first issue is resolved by adding a check for the clean request,
which should be placed just after @code{datafile} is set,

@example
if strcmp (req, 'clean') && exist (datafile, 'file')
    delete (datafile);

    % do nothing more
    deltaH = 0;
    throttle = 0;
    action = '';
    return;
end
@end example

The second issue is resolved by using the actual values for the energy
regeneration rate, @code{energy_regen} and the rifle energy cost,
@code{rifle_cost}. We also want to take into account that we are
moving (at cost @code{move_cost}) and the energy regeneration rate is
lower. First, the bot needs to obtain these values,

@example
engine_settings;
@end example

Now use the values,

@example
if rifle_timer >= rifle_cost / (energy_regen - throttle * move_cost)
    ...
end
@end example

The bot will now fire at the same rate that its energy regenerates,
helping ensure that it will never run out of energy. With certain
settings, there may be issues with divide by zero and negative
numbers. This is left as an exercise to the reader (because we don't
feel like writing it out!).

A full listing of this bot's code is in @ref{Simple Example}.

@c Targeting
@node Targeting
@section Targeting
@cindex targeting

Continuing the use of the above code, we will add targeting to the
code. There is no official targeting interface. A bot just picks a bot
and sticks with it.

This example will pick an enemy bot at random, remember that bot as a
target, and pursue the bot until it is dead. The full code for this
bot is available in the appendix. @ref{Targeting Bot}.

We want to store our target in memory (the @code{.mat} file) so we
know who we have targeted later. We will adjust the save command at
the end of the code,

@example
save (datafile, 'rifle_timer', 'target');
@end example

We also want to initialize the target, so we will put this below the
initialization of @code{rifle_timer},

@example
else
    rifle_timer = 0;
    target = -1;
end
@end example

We set it to -1 because no bot will ever have this number. It will
force the bot to choose a target right away.

Let us now check to see if our current target is alive.

@example
target_index = -1;
for i = 1:length(state)
    if state@{i@}@{6@} == target
        target_index = i;
        break;
    end
end
@end example


If our target is dead, @code{target_index} was never set. In this
case, let's choose a new target at random. To do this, we will need to
create a list of enemy bots,

@example
enemy_list = [];
enemy_index = [];
for i = 1:length(state)
    if ~strcmp(state@{i@}@{5@}, player@{5@});
        enemy_list = [enemy_list state(i)];
        enemy_index = [enemy_index i];
    end
end
@end example

If there are no enemies, we do nothing.

@example
   if isempty(enemy_list)
       deltaH = 0;
       throttle = 0;
       action = '';
       return;
   end
@end example

@code{enemy_list} is now a non-empty list of enemies for us to choose
from. Choose one at random,

@example
sel_index = ceil (rand * length(enemy_list));
target = enemy_list@{sel_index@}@{6@};
target_index = enemy_index(sel_index);
@end example

Now we have a target and know it's index into the state vector. Let's
turn our bot to face this enemy at his current position. In this
example, we will not attempt to predict enemy movement and shoot
there. This is left up to you to solve. There are many different ways
to solve this problem, some better than others.

Calculate the heading required to face the other bot,

@example
target_heading = atan2(state@{target_index@}@{2@} - player@{2@}, ...
                       state@{target_index@}@{1@} - player@{1@});
@end example

Now we set deltaH to this different, causing the bot to turn in the
correct direction,

@example
deltaH = target_heading - player@{8@};
@end example

This completes our search and destroy bot. For the full code, see
@ref{Targeting Bot}.

@c ---------------------------------------------------------------------
@c Bot Behavior
@node Bot Behavior
@chapter Bot Behavior

@menu
* Well Behaved Bots::   Bot etiquette
* Bot Plotting::        Bots plotting in the game area
* Existing Bots::       Useful bots
@end menu

@c Well Behaved Bots
@node Well Behaved Bots
@section Well Behaved Bots
@cindex well behaved

To encourage bots that interface well with the engine and other bots,
we will define a ``well behaved'' bot. A well behaved bot should,

@itemize @bullet
@item
Be quiet.

@item
Always return three values.

@item
Properly handle all requests.

@item
Not intentionally sabotage other bots.

@end itemize

Now, to detail this information.

A bot should not produce any junk output. This includes both output in
the Matlab command line window as well as putting junk on the game
window. Extra plotting on the game window is allowed, as long as it
does not interfere with watching the game, i.e. don't fill the plot
will garbage.

A bot should always return three values, especially with unknown
requests. This leads us into the next item.

A bot should be able to take any request. If a request is not known,
it should do nothing but return empty or zeroed values.

And finally, a bot should not sabotage another bot. That is, a bot
should only compete with another bot within the game
engine. Attempting to modify another bot's @file{.mat} file would be a
violation of this rule.

Of course, your bot does not @emph{have} to be well behaved. This is a
just a set of guidelines. The most interesting bots may not follow
these guidelines at all.

@c Bot Plotting
@node Bot Plotting
@section Bot Plotting
@cindex eplot

@cindex engine settings
@cindex record
Bots may draw plots and text in the game area through the @code{eplot}
interface. @code{eplot} automatically checks the engine settings to
determine how the plot is handled, if at all. The plot will also be
recorded in the game script recording (@pxref{Display Settings}).

@code{eplot} is able to do any plot that @code{plot} is capable of as
well as inserting text with the @code{text} command. When using
@code{plot}, all arguments to @code{eplot} are passed to the
@code{plot} command when a plot is made. For example,

@cindex circle
@example
eplot (cos (0:0.1:2*pi) * 3 + player@{1@}, ...
       sin (0:0.1:2*pi) * 3 + player@{2@}, ...
       'Color', player@{9@});
@end example

This will plot a circle with the player's color of radius 3 on top of
the bot. This circle will show up on all recordings and will only be
plotted during a game when @code{display_game} is set (@pxref{Display
Settings}).

@cindex text
@code{eplot} can also handle text information. You can use this to add
some personality to a bot. To use it, the first argument is
@code{'text'} and all remaining arguments are arguments to
@code{text}.

@cindex headshot
@example
eplot ('text', player@{1@}, player@{2@} + 0.3, 'BOOM! HEADSHOT!');
@end example

Will display ``BOOM! HEADSHOT!'' over the bot.

@c Existing Bots
@node Existing Bots
@section Existing Bots

Several bots are already be written, some of which should be useful in
debugging and testing the bots that you are writing. Other good for
studying techniques to be used in your bots.

@menu
* Target Dummies::    Bots good for shooting
* Team Bots::         Bots that behave as a collective
* Evasion Bots::      Bots that work well alone
@end menu

@c Target Dummies
@node Target Dummies
@subsection Target Dummies
@cindex target dummies

This collection of bots are great for testing your bots, especially
targeting algorithms. Until you have polished your bot, these will be
often be the enemy.

@cindex zombie
The @dfn{zombie} bot travels in a straight line until it reaches the
edge of the map, where it will ``bounce'' off in some other
direction. It works well for early target practice to make sure your
bot can hit targets moving in straight lines. They are also useful for
testing your bots against opponents from all around the game area, as
these bots will quickly be all over the place.

The @dfn{circler} does what its name indicates: it goes in
circles. Use this bot to test targeting algorithms because circular
motion can actually be tricky to hit unless specifically programmed
for it.

The @dfn{dummy} bot is another good bot for target practice. Their
movement is completely erratic, with all return values random. This
bot will even shoot randomly.

The @dfn{minelayer} is a zombie that drops mines. Drop in several and
the game are will be filled with mines. They turn into a dummy bot
when low on energy. If you are testing your bot on avoiding mines, use
this guy.

@c Team Bots
@node Team Bots
@subsection Team Bots

These bots communicate with each other and will work together as a
group to achieve goals.

The @dfn{teamsnipe} bot does not move. They stand in place, all agree
on a common target, and fire in unison as a team until that target
dies.

The @dfn{fallback} bot will ``fall back'' into formation in the
nearest corner of the game area. Most will act as a defensive shield
while the inside bots will concentrate on firing on targets (just by
calling teamsnipe).

The @dfn{goose} bot will fly in formation with the other geese on the
team. They gather into a V (or really a triangle) and attack a common
target while closing in. A seek and destroy group.

The @dfn{uzi} bot is the most deadly bot ever created. These guys will
work as a team to quickly eliminate several other bots in the first
few seconds of the game.

@c Evasion Bots
@node Evasion Bots
@subsection Evasion Bots

Evasion bots tend to work alone. Their main feature is evading bullets
fired from other bots, giving them huge survivability. They can easily
take on many of the above bots at once and win. These are the best
bots in the game right now.

The @dfn{evader} bot, being first of its kind, is extremely passive
and holds no grudges. It will quietly dodge anything thrown at it. It
does need privacy, however. If someone gets too close, all hell will
break loose as it unloads all of its energy on the rude bot.

The @dfn{snitch} is currently the number one bot, but it requires
immense CPU time compared to other bots. It will dodge just about
anything you can throw at it and can quickly eliminate other opponents
early on. Currently, however, the snitch is no good at close combat.

@c ---------------------------------------------------------------------
@node Simple Example
@appendix Simple Example

@example
function [deltaH throttle action] ...
                          = example_bot (state, player, objects, req)

engine_settings;

datafile = ['example-bot-' num2str(player@{6@}) '.mat'];

if strcmp (req, 'clean') && exist (datafile, 'file')
    delete (datafile);

    % do nothing more
    deltaH = 0;
    throttle = 0;
    action = '';
    return;
end

if exist (datafile, 'file')
    load (datafile);
else
    rifle_timer = 0;
end

% This code is from before
deltaH = pi / 8;
throttle = 0.5;

% Do we shoot now?
if rifle_timer >= rifle_cost / (energy_regen - throttle * move_cost)
    % reset timer
    rifle_timer = 0;

    action = 'rifle';
else
    action = '';

    % increase timer
    rifle_timer = rifle_timer + 1;
end

save (datafile, 'rifle_timer');

@end example

@c ---------------------------------------------------------------------
@node Targeting Bot
@appendix Targeting Bot

@example
function [deltaH throttle action] ...
                          = target_bot (state, player, objects, req)

engine_settings;

datafile = ['target-bot-' num2str(player@{6@}) '.mat'];

if strcmp (req, 'clean') && exist (datafile, 'file')
    delete (datafile);

    % do nothing more
    deltaH = 0;
    throttle = 0;
    action = '';
    return;
end

if exist (datafile, 'file')
    load (datafile);
else
    rifle_timer = 0;
    target = -1;
end

target_index = -1;
for i = 1:length(state)
    if state@{i@}@{6@} == target
        target_index = i;
        break;
    end
end

if target_index == -1
   enemy_list = [];
   enemy_index = [];
   for i = 1:length(state)
       if ~strcmp(state@{i@}@{5@}, player@{5@});
           enemy_list = [enemy_list state(i)];
           enemy_index = [enemy_index i];
       end
   end
   
   if isempty(enemy_list)
       deltaH = 0;
       throttle = 0;
       action = '';
       return;
   end
   
   sel_index = ceil (rand * length(enemy_list));
   target = enemy_list@{sel_index@}@{6@};
   target_index = enemy_index(sel_index);
end

% Now we set deltaH to point to this bot
target_heading = atan2(state@{target_index@}@{2@} - player@{2@}, ...
                       state@{target_index@}@{1@} - player@{1@});
deltaH = target_heading - player@{8@};

% Constant throttle
throttle = 0.5;

% Do we shoot now?
if rifle_timer >= rifle_cost / (energy_regen - throttle * move_cost)
    % reset timer
    rifle_timer = 0;

    action = 'rifle';
else
    action = '';

    % increase timer
    rifle_timer = rifle_timer + 1;
end

save (datafile, 'rifle_timer', 'target');
@end example

@c End the manual with the index.
@node Index
@unnumbered Index

@printindex cp   

@bye
